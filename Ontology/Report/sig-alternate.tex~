\documentclass{sig-alternate}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage[anythingbreaks]{breakurl}
\begin{document}
\conferenceinfo{CSC766}{'15 Spring Raleigh, North Carolina USA}

\title{Ontology-based Knowledge Representation for PORPLE}
\subtitle{[CSC766 Final Report]}

\numberofauthors{3}
\author{
\alignauthor
Feifei Wang\\
       \affaddr{North Carolina State University}\\
       \email{fwang12@ncsu.edu}
\alignauthor
Yue Zhao\\
       \affaddr{North Carolina State University}\\
       \email{yzhao30@ncsu.edu}
\alignauthor
Xipeng Shen\\
       \affaddr{North Carolina State University}\\
       \email{xshen5@ncsu.edu}
}
\maketitle
\begin{abstract}
Data placement is important for the performance of a GPU (Graphic Processing Unit) program. However, where to place the data is a complex decision for a programmer to make. Among the recent techniques in solving data placement problem, PORPLE is a representative one. PORPLE is a portable data placement engine that uses hardware information (memory systems and processors) described by memory specification language (MSL) and software information (data access patterns) gathered from a compiler called PORPLE-C. Because of the two different representations, it is hard to share common understanding of the program, and reuse information. Providing a more general, uniform and reusable representation can make data replacement decisions more efficient, interoperable and reusable.

In this paper, we apply ontology-based techniques to systematically and formally represent both hardware information and software information used by PORPLE hoping to achieve efficiency, interoperability and reusability. Specifically, we transform the information of GPU memory systems and processors, and the data access patterns gathered by PROPLE-C to ontology which can be used by PORPLE for data replacement.
 
\end{abstract}

\terms{Compiler}

\keywords{compiler, ontology, data placement}

\section{Introduction}
Data placement is essential for the performance of a GPU (Graphic Processing Unit) program \cite{related1}. However, where to place the data depends on the hardware information of the GPU and software information of the program and its input. The hardware information of the GPU includes its memory systems and processors, while the software information means the data access patterns associated with the input to the programs. The memory systems of GPUs are becoming increasingly complex. For example, there exists more than eight types of memory (including caches) on the Tesla M2075 GPU. These memories have different size limitations, block sizes, access constraints and etc. Also, the suitable placements depend on the program inputs since different inputs to a program may lead to different data access patterns, and thus require different data placement. As a result, data placement problem is difficult but should be solved.

There have been some efforts to address the data placement problem \cite{related1, related2, related3, porple}. Among them, PORPLE \cite{porple} is a representative one since it considers various types of GPU programs. PORPLE is a portable data placement engine that takes both hardware information (memory systems and processors) and software information (data access patterns) into consideration and use them to make data placement decisions. PORPLE obtains information about memory systems and processors from memory specification language (MSL), and uses the runtime profiling to acquire the data access patterns. In such a sense, PORPLE uses two different types of representations, which makes it hard to share common understanding of the program and reuse information. Providing a more general, uniform and reusable representation can improve the efficiency, interoperability and reusability of PORPLE and potentially some other work.

There exists various techniques to represent knowledge \cite{intro2}. Recently, ontology-based knowledge bases are becoming increasingly popular. Ontology is a general-purpose modeling for knowledge resources used to define a common vocabulary and a shared understanding explicitly \cite{ontology1, ontology2}. It has been successfully used to build knowledge bases in many fields \cite{ontology3, ontology4, ontology5, ontology6, work1, work2}. Motivated by their advances, we choose ontology as the representation.

In this paper, we apply ontology-based techniques to systematically and formally represent both hardware information and software information hoping to make PORPLE more efficient, interoperable and reusable. Specifically, we transform the information of GPU memory systems and processors, and the data access patterns gathered to ontology which can be used by PORPLE for data replacement. Note that although our work is applied to PORPLE, it can also be applied to other work.

This paper is organized as follows. In Section 2, we present the motivation of our work. Section 3 illustrates the challenges of the project, our solutions, and lessons we learned. In Section 4 we explain our methodology in detail. Section 5 shows the results. Section 6 concludes this paper and discusses some possible future work.

\section{Motivation}
This work is mainly motivated by an observation that PORPLE uses two different representations for hardware information and software information. Hardware information is represented by memory specification language (MSL), which is a carefully designed small specification language. It describes the memory systems of a GPU. \ref{fig:msl} shows the MSL specification of the Tesla M2075 GPU as an example. The MSL describes the properties of a type of memory and its relations with other pieces of memory in a system. For example, the second line of the file shows the properties of globalMem. The name of the memory is globalMem, its id is 8, it is software manageable, allows read and write accesses, and etc. It also shows the relations between globalMem and L2 is that globalMem has an upper level called L2. Software information, which is data access patterns, is represented by a form defined by Chen et al. \cite{porple} \ref{fig:dap} presents one data access pattern used by PORPLE. In this file, the second line shows that the total memory access time is 64, L1 cache hit is 0, and L2 cache hit is 0.

Due to the two different representations, it is hard for them to share common understanding of the program and reuse information. In such a sense, we are motivated to choose ontology as a more general, uniform and reusable representation hoping to improve the efficiency, interoperability and reusability of PORPLE and potentially some other work.

This work is also motivated by the success of some previous work of using ontology to systematically represent, reuse, and manipulate software information, hardware information and optimization information. For example, OpenK adapts ontology-based techniques to build open and reusable knowledge bases to do program analysis and optimization in HPC. Sosnovsky et al. \cite{work1} and Ganapathi \cite{work2} et al. use ontology to teach abstract programming language. Moor et al. \cite{ontology3} and Leenheer et al. \cite{ontology4} focus on community-based evolution of knowledge-intensive systems with ontology. Tang et al. \cite{ontology5} implement a profile compiler that support ontology-based, community-grounded, multilingual, collaborative group decision making by leveraging ontology. 

\begin{figure*}
\centering
\epsfig{file=msl.png,height=4cm}
\caption{The memory specification of Tesla M2075 in MSL}
\label{fig:msl}
\end{figure*}

\begin{figure}
\centering
\epsfig{file=dap.png,height=4cm}
\caption{The data access pattern used by PORPLE}
\label{fig:dap}
\end{figure}

\begin{figure*}
\centering
\epsfig{file=property.png,height=10cm}
\caption{Syntax of MSL}
\label{fig:property}
\end{figure*}

\section{Challenge, Solution and Lesson}
Transforming MSL and data access patterns used by PORPLE to ontolgoy is quite straightforward. We don't have many challenges. The main challenge is to understand ontology. In this section, we introduce the challenge to understand ontology, how we overcome them, and the lessons we learned.

\subsection{Challenge}
Ontologies have three parts: individuals, properties and classes \cite{what1}. Individuals are objects in the domain in which we are interested. Properties represent binary relations between two individuals. Objects with similar characteristics are grouped by classes. In this part we use \ref{fig:msl} as an example to illustrate the challenges. 

For the individual part, there are mainly two challenges. The first challenge is to use unique namedIndividual for each type of memory system. For example, in the MSL for Tesla M2075, although there are four textureMems, we cannot use the same name \texttt{textureMem} for all of them. We need to make sure that every namedIndividual is unique. The second challenge is that we cannot just use the memory types as namedIndividuals, e.g. L1 and L2. We must also consider the GPU vendors and types, e.g., M2075, M2075GlobalMemory and M2075ConstantMemory.

For the property part, the challenge is that we need to consider inverse property. Inverse property means that if a property links individual a to individual b then its inverse property will link individual b to individual a \cite{what1}. For example, if globalMem has an upper level that is L2, then L2 should have a lower layer that is globalMem. 

For the class part, the challenge is to consider some characteristics that is not so obvious. For example, L1 is a sub-class of Cache is obvious. However, we need to consider that M2075 is a sub-class of Tesla, M2075Processor is a sub-class of Processor, M2075GlobalMemory is a sub-class of GlobalMemory and etc.

\subsection{Solution}
Our solution is to use Protege \cite{protege} to generate ontology files, and then learn from those generated files. By learning from Protege, we learn to define classes and arrange them in a hierarchy (sub-class hierarchy). We consider Tesla, M2075, Processor, scope, GlobalMemory, ConstantMemory, TextureMemory, Cache and etc. We also learn to define the properties that should be assigned to each class and give them values. We also learn to define individuals.

\subsection{Lesson}
The lesson is that when creating ontology, we must think comprehensively. For example, we cannot just use the memory types as namedIndividuals, e.g. L1 and L2. We must also consider the GPU vendors and types, e.g., M2075, M2075GlobalMemory and M2075ConstantMemory. Similarly, when constructing the sub-class hierarchy, we cannot only consider obvious ones such as L1 is a sub-class of Cache. We must also consider that M2075 is a sub-class of Tesla, and M2075GlobalMemory is also a sub-class of GlobalMemory. Also when assigning properties to namedIndividuals, we have to consider if the properties have some special attributes such as inverse property. For example, if we give globalMem an upper level that is L2, then we should also give L2 a lower layer that is globalMem. 

\section{Implementation}
We have designed two implementations for MSL and data access patterns. We first introduce the implementation for MSL in detail, and then describe the implementation for data access patterns.

\subsection{MSL}
When transforming MSL to ontology, we create individuals and then enumerate properties about them, and assert class descriptions about them.

We first need to add various type of memory systems to our ontology. For example, globalMem, constantMem, sharedMem, are regarded as individuals. Note that when we add them, we must make sure that these memory systems is associated with M2075. As a result, we give them a prefix and make the names M2075GlobalMemory, M2075ConstantMemory, M2075SharedMemory and etc. We use namedIndividuals since they are given an explicit name that can be used in any ontology to refer to the same object. We must also add keywords such as block, core, wrap as namedIndividuals.

We then enumerate the properties of individuals. We consider the properties as shown by \ref{fig:property}, which is used by PORPLE \cite{porple}. By parsing the input file, we can get the information we need to create properties. We use two kinds of properties:

\begin{itemize}
	\item ObjectPropertyAssertion. ObjectPropertyAssertion allows one to state that an individual is connected by an object property expression to an individualIn. In MSL, we can get information about ObjectPropertyAssertion such as hasBlockSize, hasLatency, hasLowerLevel and etc.
	\item DataPropertyAssertion. DataPropertyAssertion allows one to state that an individual is connected by a data property expression to a literal. In MSL, we can get information about DataPropertyAssertion such as CoresPerSM, numberofCoresValue, threadsPerBlock and etc.
\end{itemize}

In the end, we define sub-class hierarchy to state that an individual is an instance of a particular class. For example, M2075ConstantMemory is a sub-class of ConstantMemory, M2075GlobalMemory is a sub-class of GlobalMemory, cL1 is a sub-class of L1\_constant and etc. 

\subsection{Data Access Patterns}
Transforming data access patterns to ontology is quite easy since the semantics of data access patterns is simple. For example, for an input file as shown in \ref{fig:dap}, we only need to create namedIndividuals for the memory types. For properties, we group the numbers follow the names into groups of three numbers as designed by Chen et al. \cite{porple} We only need to consider four properties:

\begin{itemize}
	\item Total memory access time. Total memory access time is the first number in the group.
	\item L1 cache hit. L1 cache hit is the second number in the group.
	\item L2 cache hit. L2 cache hit is the third number in the group.
	\item Off-chip memory access time. Off-chip memory access time is total memory access time minus L1 cache hit and minus L2 cache hit.
\end{itemize}

Note that when parsing the input file, we neglect numbers begin with 9 since they are considered not applicable by PORPLE \cite{porple}.

Also, for data access patterns, they do not have the sub-class hierarchy. 

\section{Results}

\begin{figure*}
\centering
\epsfig{file=output1.png,height=6.5cm}
\caption{Example ontology representation for MSL}
\label{fig:output1}
\end{figure*}

\begin{figure*}
\centering
\epsfig{file=output2.png,height=5cm}
\caption{Example ontology representation for data access patterns}
\label{fig:output2}
\end{figure*}

\ref{fig:output1} shows the results of transforming MSL to ontology, and \ref{fig:output2} shows the results of transforming data access patterns to ontology. We first explain \ref{fig:output1}, then explain \ref{fig:output2}.

\subsection{Ontology representation for MSL}

In \ref{fig:output1}, there are:
\begin{itemize}
	\item namedIndividual. 
	\item propertyAssertion. 
	\item classAssertion. 
\end{itemize}

For example, namedIndividual('M2075globalMem') means that M2075globalMem is a particular kind of memory system. It can be used in propertyAssertion and classAssertion.

There are many propertyAssertions. We list a few properties here as an example of how to illustrate the ouput.
 
propertyAssertion('consistsOf','M2075','M2075globalMem') means that M2075globalMem is consisted of by M2075.
propertyAssertion('hasID','M2075globalMem',literal(type('http://www.w3.org/2001/XMLSchema#integer','8'))) means that M2075globalMem has an ID which is 8.
propertyAssertion('softwareManageable','M2075globalMem',literal(type('http://www.w3.org/2001/XMLSchema#boolean','true'))) means that M2075globalMem is software manageable.
propertyAssertion('accessible','M2075globalMem',literal(rw)) means that M2075globalMem has read and write access.
propertyAssertion('hasSizeValue','M2075globalMem',literal('5375M')) has a size of 128B.
propertyAssertion('hasBlockSizeValue','M2075globalMem',literal('128B')) means that the block size of M2075globalMem is 128B.
propertyAssertion('threadsGroup','M2075globalMem',literal(type('http://www.w3.org/2001/XMLSchema#integer','32'))) means that M2075globalMem has threadGroup of 32.
propertyAssertion('hasLatencyValue','M2075globalMem',literal('600clk')) means the latency value of M2075globalMem is 600clk.
propertyAssertion('hasUpperLevel','M2075globalMem','L2') means that M2075globalMem has an upper level that is L2.

Since M2075globalMem is a kind of GlobalMemory, we need to construct a sub-class hierarchy that by specifying classAssertion('GlobalMemory','M2075globalMem').

\subsection{Ontology representation for Data Access Patterns}

In \ref{fig:output2}, there are:
\begin{itemize}
	\item namedIndividual. 
	\item propertyAssertion. 
\end{itemize}

For example, namedIndividual('global') means that this access pattern is for global memory system. It is also used in propertyAssertion and classAssertion.

There are only four kinds of properties for data access patterns.
 
propertyAssertion('MemoryAccessTime','global',literal(type('http://www.w3.org/2001/XMLSchema#integer','64'))) means that global memory access time is 64.
propertyAssertion('L1CacheHit','global',literal(type('http://www.w3.org/2001/XMLSchema#integer','0'))) means that L1 cache hit is 0.
propertyAssertion('L2CacheHit','global',literal(type('http://www.w3.org/2001/XMLSchema#integer','0'))) means that L2 cache hit is 0 too.
propertyAssertion('OffChipMemoryAccessTime','global',literal(type('http://www.w3.org/2001/XMLSchema#integer','64'))) means that off-chip memory access time is 64.

\section{Conclusion and Future Work}
Data placement has a great influence on GPU programs, which makes data placement problem an important issue for GPU program performance. Current techniques to solve data placement problem use different representations of information, e.g., PORPLE, which is hard to share common understanding of the program, and reuse information. 

We provide a more general, uniform and reusable representation by using ontology-based techniques to make data replacement decisions more efficient, interoperable and reusable. In our work, we transform the information of GPU memory systems and processors, and the data access patterns gathered by PROPLE-C to ontology which can be used by PORPLE for data replacement.

Although our work is designed for PORPLE, it can be applied to other works as well. In the future, we may want to transform more memory related representatiions to ontology to achieve a more general information sharing and reuse.

\section{Acknowledgments}
Dr. Xipeng Shen helped me to choose the topic for the final project of CSC766. Yue Zhao and Guoyang Chen offered me a lot of help to get started with this project. The OpenK project developed by Chunhua Liao et al. helped enhance the presentation of the project.

\bibliographystyle{abbrv}
\bibliography{sigproc} 

\end{document}
\begin{thebibliography}{10}

\bibitem{porple}
G.~Chen, B.~Wu, D.~Li, and X.~Shen.
\newblock Porple: An extensible optimizer for portable data placement on gpu.
\newblock In {\em Microarchitecture (MICRO), 2014 47th Annual IEEE/ACM
  International Symposium on}, pages 88--100. IEEE, 2014.

\bibitem{ontology4}
P.~De~Leenheer and R.~Meersman.
\newblock Towards community-based evolution of knowledge-intensive systems.
\newblock In {\em On the Move to Meaningful Internet Systems 2007: CoopIS, DOA,
  ODBASE, GADA, and IS}, pages 989--1006. Springer, 2007.

\bibitem{ontology3}
A.~De~Moor, P.~De~Leenheer, and R.~Meersman.
\newblock Dogma-mess: A meaning evolution support system for
  interorganizational ontology engineering.
\newblock In {\em Conceptual structures: Inspiration and application}, pages
  189--202. Springer, 2006.

\bibitem{work2}
G.~Ganapathi, R.~Lourdusamy, and V.~Rajaram.
\newblock Towards ontology development for teaching programming language.
\newblock In {\em World Congress on Engineering}, 2011.

\bibitem{protege}
J.~H. Gennari, M.~A. Musen, R.~W. Fergerson, W.~E. Grosso, M.~Crub{\'e}zy,
  H.~Eriksson, N.~F. Noy, and S.~W. Tu.
\newblock The evolution of prot{\'e}g{\'e}: an environment for knowledge-based
  systems development.
\newblock {\em International Journal of Human-computer studies}, 58(1):89--123,
  2003.

\bibitem{ontology1}
T.~R. Gruber.
\newblock Toward principles for the design of ontologies used for knowledge
  sharing?
\newblock {\em International journal of human-computer studies},
  43(5):907--928, 1995.

\bibitem{ontology2}
N.~Guarino.
\newblock Formal ontology, conceptual analysis and knowledge representation.
\newblock {\em International journal of human-computer studies},
  43(5):625--640, 1995.

\bibitem{what1}
M.~Horridge, H.~Knublauch, A.~Rector, R.~Stevens, and C.~Wroe.
\newblock A practical guide to building owl ontologies using the
  prot{\'e}g{\'e}-owl plugin and co-ode tools edition 1.0.
\newblock {\em University of Manchester}, 2004.

\bibitem{related1}
B.~Jang, D.~Schaa, P.~Mistry, and D.~Kaeli.
\newblock Exploiting memory access patterns to improve memory performance in
  data-parallel architectures.
\newblock {\em Parallel and Distributed Systems, IEEE Transactions on},
  22(1):105--118, 2011.

\bibitem{ontology6}
A.~S. Kleshchev.
\newblock How can ontologies contribute to software development?
\newblock In {\em Knowledge Processing and Data Analysis}, pages 121--135.
  Springer, 2011.

\bibitem{related2}
W.~Ma and G.~Agrawal.
\newblock An integer programming framework for optimizing shared memory use on
  gpus.
\newblock In {\em High Performance Computing (HiPC), 2010 International
  Conference on}, pages 1--10. IEEE, 2010.

\bibitem{work1}
S.~Sosnovsky and T.~Gavrilova.
\newblock Development of educational ontology for c-programming.
\newblock 2006.

\bibitem{ontology5}
Y.~Tang, S.~Christiaens, K.~Kerremans, and R.~Meersman.
\newblock Profile compiler: Ontology-based, community-grounded, multilingual
  online services to support collaborative decision making.
\newblock In {\em Research Challenges in Information Science, 2008. RCIS 2008.
  Second International Conference on}, pages 279--288. IEEE, 2008.

\bibitem{intro2}
F.~Van~Harmelen, V.~Lifschitz, and B.~Porter.
\newblock {\em Handbook of knowledge representation}, volume~1.
\newblock Elsevier, 2008.

\bibitem{related3}
B.~Wang, B.~Wu, D.~Li, X.~Shen, W.~Yu, Y.~Jiao, and J.~S. Vetter.
\newblock Exploring hybrid memory for gpu energy efficiency through
  software-hardware co-design.
\newblock In {\em Proceedings of the 22nd international conference on Parallel
  architectures and compilation techniques}, pages 93--102. IEEE Press, 2013.
\end{thebibliography}
